-- B tree 데이터 삭제
-- 오늘 주제에서 기억해야 할 것 : (ceiling)M/2 - 1 <- 각 노드의 최소 Key 수. 여기서 M은 각 노드의 최대 자녀 노드 수.

-- 데이터 삭제 또한 항상 leaf 노드에서 발생
-- 삭제 후 최소 key 수 보다 적어졌다면, 그 tree를 재조정함. 3차 B tree에서의 각 노드의 최소 key tn : 1개(root node 제외)
-- 1. key 수가 여유있는 형제의 지원을 받는다.
-- 2. 1번이 불가능하면 부모의 지원을 받고 형제와 합친다.
-- 3. 2번 후 부모에 문제가 있다면 거기서 다시 재조정한다.

-- 삭제 후 최소 키보다 적다면,
-- 1. key의 수가 여유있는 형제의 지원을 받는다.
-- 1.1) 동생(왼쪽 형제)이 여유가 있으면,
-- > 동생의 가장 큰 key를 부모 노드의 나와 동생 사이에 둔다.
-- > 원래 그 자리에 있던 key는 나의 가장 왼쪽에 둔다.
-- 1.2) 그게 아니라 형(오른쪽 형제)이 여유가 있으면,
-- > 형의 가장 작은 key를 부모 노드의 나와 형 사이에 둔다.
-- > 원래 그 자리에 있던 key는 나의 가장 오른쪽에 둔다.

-- 2. 형제의 지원이 불가능하다면, 부모의 지원을 받고 형제와 합친다.
-- 2.1) 동생이 있으면 동생과 나 사이의 key를 부모로부터 받는다.
-- > 그 key와 나의 key를 차례대로 동생에게 합친다. ** 합칠 땐, 항상 왼쪽으로 합친다.
-- > 나의 노드를 삭제한다.
-- 2.2) 동생이 없으면 형과 나 사이의 key를 부모로부터 받는다.
-- > 그 key와 형의 key를 차례대로 네에게 합친다. ** 합칠 땐, 항상 왼쪽으로 합친다.
-- > 형의 노드를 삭제한다.

-- 3. 부모가 지원한 후, 부모 노드에 문제가 있다면 상황에 맞게 대응한다.
-- 3.1) 부모가 root 노드가 아니라면,
-- > 그 위치에서부터 다시 1번부터 재조정을 시작한다.
-- 3.2) 부모가 root 노드이고, 비어있다면,
-- > 부모 노드를 삭제한다.
-- > 직전에 합쳐진 노드가 root 노드가 된다.


-- internal 노드의 데이터 삭제는 어떻게 진행되는가?
-- 항상 leaf 노드에서 삭제하고 필요하면 재조정한다면, leaf 노드가 아닌 internal 노드의 데이터 삭제는?
-- > internal 노드에 있는 데이터를 삭제하려면, leaf 노드에 있는 데이터와 위치를 바꾼 후 삭제한다.

-- 이때, 위치를 바꿀 데이터 중, predecessor(나보다 작은 데이터들 중 가장 큰 데이터: 선임자)와 successor(나보다 큰 데이터들 중 가장 작은 데이터: 후임자) 중 상황에 맞게 선택하여 위치를 바꿈
